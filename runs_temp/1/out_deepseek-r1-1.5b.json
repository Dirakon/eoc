["<explanation>\nEO is a minimalistic functional programming language designed for concise code. It uses objects as both types of functionsâ€”parametrized (with arguments) and non-parametrized (without parameters but returning text). Non-parametrized functions return text like \"hello world\", while parametrized functions define inner objects similar to classes, capturing values within them.\n</explanation>\n<doctest-code>\n[] > print-something\n  \"hello world\"\n</doctest-code>\n<doctest-output>\nPrinting \"hello world\" in EO.\n</doctest-output>\n\n<explanation>\nNon-parametrized functions like `print-something` return text without arguments. They are simple and direct:\n```eo\n[x] > slice /string\n  \"hello world\"\n```\nThey simply return a string, bypassing any processing.\n\nParametrized functions (e.g., defining classes) capture values into objects. Each parametrized function becomes an inner object, such as in the example where `@` is defined with parameters and methods.\n</explanation>\n<doctest-code>\n[function-arg] > print-something\n  QQ.io.stdout > @\n    function-arg\n</doctest-code>\n<doctest-output>\nFunction `print-something` takes an argument `function-arg` which then calls another method with that argument captured into the inner object.\n</doctest-output>","<explanation>\nThis object represents an NixOS configuration where multiple arguments or branches are chained together. Each argument set in brackets is passed sequentially through the functionality of the object until a final command is executed.\n\n</explanation>\n<doctest-code>\n[object-arg1] > app\n  print-hello-world > @\n    \"hello world\"\n</doctest-code>\n<doctest-output>\nThe above code defines an object with arguments ['object-arg1']. It starts by printing \"hello world\" after processing the initial argument.\n</doctest-output>","<explanation>\nMetalic Functional Language (MFL) is a minimalist functional programming language designed to simplify object creation by allowing objects to be constructed using specific syntax. Objects can have methods defined in two primary ways:\n\n1. **Parametrized Functions**: Methods are written with parameters, and these functions can handle different cases based on the provided arguments. For example:\n   ```eo\n   [object-arg] > obj\n     print-hello-world > @\n       #<OBJECT-BELOW-IS-TO-BE-DOCUMENTED>\n         [function-arg] > print-something\n           QQ.io.stdout > @\n             function-arg\n   ```\n   Here, the method `print-something` takes an argument and defines a submethod `@`.\n\n2. **Non-Parameterized Functions**: Methods can be defined without arguments but may have overloaded variants with different parameters. For example:\n   ```eo\n   [function-arg] > print-something\n     QQ.io.stdout > @\n       function-arg\n   ```\n   This allows the method to handle cases based on the presence or absence of arguments.\n\nThe explanation should also outline how MFL handles chained methods, such as:\n\n- **Chaining**: Methods are chained together in a left-associated manner. For example:\n  ```eo\n  [object] > f\n    print-hello-world > @\n      #<OBJECT-BELOW-IS-TO-BE-DOCUMENTED>\n      [function] > g\n        QQ.io.stdout > @\n          function\n  ```\n  Here, the object `f` calls a method with arguments, and then defines another function `g`.\n\nThe doctest examples should test these concepts. For instance:\n\n1. **Parametrized Function**:\n   ```eo\n   [] > string\n     [function-arg] > print-something\n       \"hello world\"\n   ```\n   This should output:\n   ```\n   []\n   > string\n   2 spaces > @\n   \"hello world\"\n   ```\n\n2. **Non-Parameterized Function**:\n   ```eo\n   [] > object\n     [function-arg] > print-something\n       QQ.io.stdout > @\n         function-arg\n   ```\n   This should output:\n   ```\n   []\n   > object\n   1 space > @\n   \"hello world\"\n   ```\n\nThese examples demonstrate how MFL allows for concise and efficient object creation by enabling method definitions using parameters or without arguments.\n</explanation>\n\n<doctest-code>\n[] > string\n    [function-arg] > print-something\n      \"hello world\"\n</doctest-code>\n<doctest-output>\n\"hello world\"\n</doctest-output>\n```","The task requires documentation of the `eo` programming language, focusing on its minimalistic functional style. The key points include understanding expressions, function chaining, and different ways to define functions.\n\n### Explanation:\n- **EO is a Minimalistic Functional Language**: It uses short syntax where everything is an expression, allowing for concise code.\n- **Expressions**: They start with `obj >` followed by operations or outputs.\n- **Chaining**: Functions are chained using `>`, evaluating from left to right.\n- **Special Function @**: Defines how the object evaluates.\n\n### Defining Functions:\n1. **Parametrized (With Parameters)**: \n   - Example: `[object] > print-something`\n     - Returns another function or expression ready for evaluation.\n2. **Non-Parametrized**:\n   - Example: `[] > print-something`\n     - Directly returns the result, without requiring parameters.\n\n### Doctest Code Examples:\n```eo\n# Parametrized Function with Square Brackets\n[a] > print\n  QQ.io.stdout > @\n    a\n```\n\n```eo\n# Non-Parametrized Function\n[] > function-name\n  \"hello\"\n```\n\n### Explanation of Each Example:\n\n1. **Parametrized Function**:\n   - `a` is an argument (implicitly empty list). Returns another function.\n   - Chaining: Each result evaluates to the next step until @.\n\n2. **Non-Parametrized Function**:\n   - Direct return without arguments, using square brackets for object chaining.\n   - Works as a simple expression returning the value immediately after waiting with @.\n\n### Expected Outputs in Doctest:\n\n```eo\n<doctest-code>\n[a] > print\n  QQ.io.stdout > @\n    a\n\n[] > function-name\n  \"hello\"\n</doctest-code>\n\n<doctest-output>\nfunction-name\nhello\n</doctest-output>\n```\n\nThis documentation explains how `eo` works, its defining methods, and provides clear test cases for each approach.","The EO programming language is based on functional programming with minimalistic syntax. Each line after an object definition (the left side of '>') represents state, while the right side describes operations.\n\n**Explanation:**\n- **State Representation:** Objects are built using commas to represent different properties. For example, `[a b]` starts a new property, which is modified by subsequent operations.\n  \n**Doctest Code:**\n```eo\n[a b] > app\n  add. > @\n    \"Hello World\"\n```\n\n**Doctest Output:**\n```python\n<explanation>\nEO programming language defines classes and functions using state representation with commas to separate properties. For example, [a b] starts a new property that can be modified by operations like 'add.'.\n</explanation>\n<doctest-code>\n[a b] > app\n  add. > @\n    \"Hello World\"\n</doctest-code>\n<doctest-output>\n\"Hello World\"\n</doctest-output>\n```"]