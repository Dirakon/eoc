# The code defines a complex system for managing and tracking versions of software programs, potentially within a NixOS environment. Let's break down the key components:
# **1. `app` Object:**
# *   This is the main entry point. It accepts command-line arguments (`args`), specifically the path to a state directory where program data is stored.
# *   It iterates indefinitely, querying external sources for the latest program versions and updating the stored data.  The `while true` loop suggests it's designed to run continuously.
# *   Inside the loop, it retrieves program name and branch, reads the currently saved data, fetches the current version, actualizes the data with the new version, and writes it back to storage. Finally, it outputs the updated data as an RSS feed.
# **2. `version` Object:**
# *   Given a branch and program name, it retrieves the current version number from an external source. It then creates a `program-version` object, which encapsulates the version number and the current Unix timestamp.
# **3. `currently-saved-data` Object:**
# *   Retrieves the data that is currently saved by branch and program name, or returns an empty program data object if no data exists.
# **4. `current-time` Object:**
# *   Gets the current time using the `gettimeofday` POSIX system call; it converts it into seconds since the Epoch.
# **5. `program-data-storage` Object:**
# *   Handles reading and writing the program data to persistent storage, using the specified `state-path`. It creates files and directories as necessary within the state directory.
# **6. `program-data` Object:**
# *   Represents the data for a given program, including its name and a list of versions.
# *   `output-as-rss` formats the version history as an RSS feed and prints it to standard output. Notably, it contains some lines that output directly to `QQ.io.stdout` and a line-counter, which suggests it might interact with external scripts or a monitoring tool.
# *   `actualized` determines if the version is new and adds the version if appropriate to the data object.
# **7. `program-version` Object:**
# *   A simple object that combines a version number and a Unix timestamp.
# **8. `external` Object:**
# *   Acts as an interface to external commands or data sources.
# *   It defines commands for getting the current branch, program name and version (through `send-command`), as well as for reading and writing files.  The commands are communicated via standard input/output (stdin/stdout).
# *   It includes the functions to send command, get a response from stdin, get a confirmation from stdin (likely after writing a file) and logging facilities. It also includes the `line-counter` object used for echoing the number of output lines.
# In essence, this code defines a system that periodically checks for new versions of programs and stores their version history in a file system.  It presents this history as an RSS feed, potentially for monitoring or notification purposes. Communication with external tools (e.g., to retrieve version numbers) is handled via standard input and output.
[args] > app
  QQ.fs.path > state-path
    args.at 0
  seq > @
    *
      while
        true > [i] >>
        [i] >>
          seq > @
            *
              external.branch > branch
              external.program-name > program-name
              external.log
                "Reading..."
              currently-saved-data > data
                branch
                program-name
              external.log
                "Getting current version"
              version > current-version
                branch
                program-name
              data.actualized > new-data
                current-version
              program-data-storage > storage
                state-path
              external.log
                "Writing..."
              storage.write
                new-data
              new-data.output-as-rss

  [branch program-name] > version
    seq > @
      *
        external.version > version-number
          branch
          program-name
        program-version
          version-number
          current-time.tv-sec

  [branch program-name] > currently-saved-data
    seq > @
      *
        program-data-storage > storage
          state-path
        storage.read > data
          branch
          program-name

  [] > current-time
    output. > @
      QQ.sys.posix
        "gettimeofday"
        * QQ.sys.posix.timeval

# <STRUCTURE-BELOW-IS-TO-BE-DOCUMENTED>
[state-path] > program-data-storage
  state-path > @
  [branch program-name] > data-file
    QQ.fs.file > file
      QQ.fs.path.joined
        *
          state-path
          QQ.fs.path
            branch
          QQ.fs.path
            program-name
    QQ.fs.dir > directory
      QQ.fs.file
        QQ.fs.path
          file.dirname
    seq > @
      *
        directory.made
        file

  [branch program-name] > read
    data-file > file
      branch
      program-name
    file.path > src
    seq > @
      *
        if.
          exists.
            QQ.fs.file
              src
          seq
            *
              external.read > content
                file
              program-data
                branch
                program-name
                mapped.
                  QQ.structs.list
                    split.
                      content
                      "\n"
                  [line] >>
                    program-version > @
                      at.
                        QQ.txt.sscanf
                          "%s|||%d"
                          line
                        0
                      at.
                        QQ.txt.sscanf
                          "%s|||%d"
                          line
                        1
          seq
            *
              program-data
                branch
                program-name
                QQ.structs.list
                  tuple.empty

  [program-data-instance] > write
    data-file > file
      program-data-instance.branch
      program-data-instance.program-name
    seq > @
      *
        program-data-instance.versions.reduced > serialized-versions
          QQ.txt.text
            ""
          [accum version]
            chained. > @
              accum
              *
                QQ.txt.text
                  version.version-number
                QQ.txt.text
                  "|||"
                QQ.txt.text
                  QQ.txt.sprintf
                    "%d"
                    * version.timestamp
                QQ.txt.text
                  "\n"
        external.log
          serialized-versions
        external.write
          file
          serialized-versions
        program-data-instance

# <STRUCTURE-BELOW-IS-TO-BE-DOCUMENTED>
[branch program-name versions] > program-data
  program-name > @

  # Have some weird stackoverflow problems if I try to separate rss-string creation and the output.
  # Therefore, I have to break responsibilities here and unify rss-string creation and the ouput.
  [] > output-as-rss
    QQ.txt.sprintf > prefix
      "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n\n<channel>\n  <title>%s versions</title>\n  <link>https://search.nixos.org/packages?channel=%s&from=0&size=50&sort=relevance&type=packages&query=%s</link>\n  <description>History of versions</description>"
      * program-name branch program-name
    [] > output-middle-part
      seq > @
        mapped.
          versions
          [version] >>
            QQ.io.stdout > @
              QQ.txt.sprintf
                "  <item>\n    <title>%s</title>\n    <link>https://search.nixos.org/packages?channel=%s&from=0&size=50&sort=relevance&type=packages&query=%s</link>\n    <description>New version at %d</description>\n  </item>\n"
                * version.version-number branch program-name version.timestamp
    "</channel>\n\n</rss>" > suffix
    seq > @
      *
        QQ.io.stdout
          "Rss:\n"
        5.times versions.length > number-of-lines-middle
        7 > prefix-lines
        3 > suffix-lines
        (number-of-lines-middle.plus prefix-lines).plus suffix-lines > number-of-lines
        external.line-counter number-of-lines
        QQ.io.stdout
          prefix
        QQ.io.stdout
          "\n"
        output-middle-part
        QQ.io.stdout
          suffix
        QQ.io.stdout
          "\n"

  # <STRUCTURE-BELOW-IS-TO-BE-DOCUMENTED>
  [new-version] > actualized
    program-data > @
      branch
      program-name
      if.
        and.
          eq.
            last-index-of.
              versions
              new-version
            versions.length.minus 1
          not.
            versions.is-empty
        versions
        versions.with new-version

# <STRUCTURE-BELOW-IS-TO-BE-DOCUMENTED>
[version-number timestamp] > program-version
  version-number > @

# <STRUCTURE-BELOW-IS-TO-BE-DOCUMENTED>
[] > external
  "" > @
  "|||" > command-separator

  [line-count] > line-counter
    QQ.io.stdout > @
      QQ.txt.sprintf
        "(lines: %d)\n"
        * line-count

  [content] > output-multiline
    QQ.txt.text > text-content
      content
    split. > lines
      text-content
      "\n"
    seq > @
      *
        line-counter
          lines.length
        QQ.io.stdout
          QQ.txt.sprintf
            "%s\n"
            * content

  [text] > log
    seq > @
      *
        QQ.io.stdout
          "Log:\n"
        output-multiline
          text

  [file content] > write
    QQ.txt.text > write-file
      "write-file"
    seq > @
      *
        send-command
          write-file.chained
            * command-separator file.as-path
        output-multiline content
        get-confirmation

  [file] > read
    [items] > range
      QQ.structs.range > @
        []
          [num] > build
            num > @
            build (@.plus 1) > next
          build 0 > @
        items
    QQ.txt.text > read-file
      "read-file"
    seq > @
      *
        send-command
          read-file.chained
            * command-separator file.as-path
        QQ.io.stdin.next-line > metadata
        (QQ.txt.sscanf "(lines: %d)" metadata).at 0 > line-count
        joined. > content
          QQ.txt.text
            "\n"
          mapped.
            range
              line-count
            QQ.io.stdin.next-line > [i]
        content

  [command] > send-command
    QQ.io.stdout > @
      chained.
        QQ.txt.text
          "Request: "
        *
          QQ.txt.text
            command
          QQ.txt.text
            "\n"

  [] > get-response
    seq > @
      *
        QQ.io.stdin.next-line

  [] > get-confirmation
    seq > @
      *
        QQ.io.stdin.next-line

  [branch program-name] > version
    QQ.txt.text > get-version
      "get-version"
    seq > @
      *
        send-command
          get-version.chained
            * command-separator branch command-separator program-name
        get-response > version-number
        version-number

  [] > branch
    QQ.txt.text > get-branch
      "branch"
    seq > @
      *
        send-command
          get-branch
        get-response

  [] > program-name
    QQ.txt.text > program-name
      "program-name"
    seq > @
      *
        send-command
          program-name
        get-response

# Doctest
[] > doctest-entry
  seq > @
    *
      QQ.io.stdout
        "<MEANINGFUL-OUTPUT-START>"
      doctest
      QQ.io.stdout
        "<MEANINGFUL-OUTPUT-END>"

# Doctest
doctest = """
QQ.io.stdout "doctest is running\\n"
"""